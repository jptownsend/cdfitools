function QuadrantFix% This program presents a square of stereomotion in one corner of the array% alternating with a central fixation target% each condition is one halfPeriod in duration% The parameters as specified up in lines 16-54% To show the stereomotion in a bincularly uncorrelated base, set base = 8 at line 54% The sequence of stereomotion sauare locations prints out continuously and saves at the end% To suppress printing, add semicolon to lines 203 and 251% msb -- porting from PTB 2 to PTB 3 has resulted in ridiculous method of% animation. needs to be rewritten. 04/11/10% FIXME: roll into CSM.m %% initialize% block timinghalfPeriod = 2; nCycles = 12;   secsToDiscard =  3; %disparity mag nitudedispMagn = -21;  % prestimulus delaysecsCountDown = 0;dTPlan = 0.005; planFreq = round(1/dTPlan); % time sampling in the experimental planspeed=menu('Frame rate?','8Hz' );if speed==1    dT = 0.05; %dynamic frame rate/s. else    dT = 0.25; %dynamic frame rate/s.endclose(gcf);sizeX = 600 ;sizeY = 600;sizeDot = 2;  % must go evenly into sizeX and Y% where is stereo square?offsetSter = 0.1; % x andy distance inset into background proportion of fieldsizeSter = 0.25; %size of the stereomotion square, proportion of fieldsizeFix = 20; %number of pixels for fixation targetdens = .10; % dot density%surfaceType = menu('Surface', 'plane', 'bar', 'quadrant');surfaceType = 3; % quadrant%motionType = menu('Motion', 'step', 'sin');motionType = 1; % step% choice = menu('Simulus Disparity Change Frequency', '0.33 Hz','1 Hz', '2 Hz');% switch choice%     case 1, period = 3;%     case 2, period = 1;%     case 3, period = 0.5;% endperiod = halfPeriod * 2;%fixType = menu('Fixation', 'cross', 'nonius', 'both', 'none');ft = 1; % fixType cross% % choice = menu('Tracking', 'no', 'yes');% fixMov = choice-1;fixMov = 0; % no trackingbase = 0; %set base = 8 for binoc uncorr base field% sterRect = [0,0,sizeDot*sizeX,sizeDot*sizeY];sizeXY = sizeX*sizeY;% centerInd = (sizeX/2+0.5)*sizeY;nHalfPeriodPlan = round(halfPeriod*planFreq);% exp plan sampled every dTPlan=5 msexpPlan = [+(1:nHalfPeriodPlan), +(1:nHalfPeriodPlan)]; % 1 cycle, no fix periodexpPlan = expPlan * halfPeriod/nHalfPeriodPlan;expPlan = kron(ones(1,nCycles+1),expPlan); % repeat nCycles+1 cyclesexpPlan = expPlan((2*nHalfPeriodPlan+1-planFreq*secsToDiscard):end); % nCycles + secsToDiscard upfront% white dots, yellow fixationplaneClut{1} = 255*[0,0,0;1,1,1];planeClut{2} = 255*[0,0,0;1,1,1];planeClut{3} = 255*[0,0,0;1,1,0];% planesplane0 = zeros(sizeY,sizeX);plane1 = ones(sizeY,sizeX);plane2 = plane1; plane2(round(sizeY*2/5)+1:round(sizeY*3/5),:) = 0;	% stripeplane3 = base*plane1; plane3((1:round(sizeSter*sizeY)),...    (1:round(sizeSter*sizeX))) = 1;	% quadrant% making cluts for the movieclut{1} = CombineCluts(planeClut,[1,0,2]);clut{2} = CombineCluts(planeClut,[0,1,2]);%% screensInitializeMatlabOpenGL([], 0, 1);screenNumber=[1,2];for n = 1:2    window(n) = Screen('OpenWindow',screenNumber(n),0); end%% defining rectangles% windowRect = Screen(window(1),'Rect');% preparing fixationstmp = zeros(sizeY,sizeX);tmp(sizeY/2-sizeFix/2+1:sizeY/2+sizeFix/2 , sizeX/2-sizeFix/8+1:sizeX/2+sizeFix/8)=1;tmp(sizeY/2-sizeFix/8+1:sizeY/2+sizeFix/8 , sizeX/2-sizeFix/2+1:sizeX/2+sizeFix/2)=1;fixInds{1} = find(tmp(:));	%cross fixation% tmp = zeros(sizeY,sizeX);% tmp(sizeY/2-sizeFix/2+1:sizeY/2+sizeFix/2,sizeX/2-sizeFix/2+1:sizeX/2+sizeFix/2)=1;% fixInds{1} = find(tmp(:));	%squaretmp = zeros(sizeY,sizeX);tmp(sizeY/2-2*sizeFix:sizeY/2-1,sizeX/2) = 1;fixInds{2} = find(tmp(:));	% nonius lefttmp = flipud(tmp);fixInds{3} = find(tmp(:));	% nonius rightfixInds{4} = union(fixInds{1},2*sizeFix*sizeY+fixInds{2}); % square+nonius leftfixInds{5} = union(fixInds{1},2*sizeFix*sizeY+fixInds{3}); % square+nonius rightplaneToBe{1} = plane0; planeToBe{2} = plane0;Screen('MatlabToFront')fprintf('Press shift key and movie will start immediately');KbPressWait;time0 = GetSecs;toStart = 0;dt = secsCountDown;%%while 1    time1 = GetSecs;    tmp = ceil(1 - time1 + time0);    if tmp < 0, break, end    if tmp ~= dt        dt = tmp;        for n=1:2 %for the two screens            % put fixation            ster{n} = plane0; %#ok<*SAGROW>            if n == 1                ster{n}(fixInds{1}) = 4;            else                ster{n}(fixInds{1}) = 4;            end            tex(n) = Screen('MakeTexture',window(n),ster{n});            moglClutBlit(window(n),tex(n),clut{1});            Screen('Flip', window(n));        end        if toStart == 0            toStart = 1;            time0 = GetSecs;        end    endend%%time0 = GetSecs;t0 = time0;expPlanOld=1;%%sterLoc = [];yLoc=0; xLoc=0;dispMod = 1;for k=1:1000000000    planeBeen{1} = planeToBe{1}; planeBeen{2} = planeToBe{2};    t1 = GetSecs;    t = t1 - t0;    nT = ceil(t*planFreq);    if nT > length(expPlan), break, end    planeToChange = rem(k,2);        %% making the disparity map    % nHalfPeriodPlan    switch motionType        case 1, %square jump            if expPlan(nT) < 0 % null epoch                if surfaceType == 1                    dispMod = 0;                elseif surfaceType == 2                    dispMod = 1;                elseif surfaceType == 3                    dispMod = base;                end            else                if surfaceType == 3 %test epoch (square)                    if expPlan(nT) < expPlanOld % This only happens at the resets                        plane3 = base*plane1; %reinitializing plane3                        plane3((round(offsetSter*sizeY)+1:round((offsetSter+sizeSter)*sizeY))...                            ,(round(offsetSter*sizeX)+1:round((offsetSter+sizeSter)*sizeX))) = 1;	% square                                                if (rand>0.5)% location of the square, always move                            xLoc = mod(1,xLoc);                        else                            yLoc = mod(1,yLoc);                        end                        sterLoc = [sterLoc 2*xLoc+yLoc+1]; %#ok<*AGROW> %Location counter                        fprintf('x%d y%d \n',xLoc,yLoc);                        if yLoc == 1                             plane3 = flipud(plane3);                        end                        if xLoc == 1                            plane3 = fliplr(plane3);                        end                    end %if expPlan(nT)                    expPlanOld = expPlan(nT);                end                if dispMod < period/2                    dispMod = 1;                else                    dispMod = -1;                end            end %if expPlan(nT)            if surfaceType == 1 		   % plane                disp = round(dispMagn*dispMod)*plane1;            elseif surfaceType == 2 		% bar                disp = round(dispMagn*dispMod)*plane2;            elseif surfaceType == 3			%square                disp = round(dispMagn*dispMod)*plane3;            end        case 2, %sinusoidal motion            if expPlan(nT) < 0  	% null epoch                if surfaceType == 1 % plane                    dispMod = 0;                elseif surfaceType == 2 % bar                    dispMod = 1;                elseif surfaceType == 3  % square                    dispMod = base;                end                disp = round(dispMagn*dispMod)*plane3;                            else   					% test epoch                dispMod = sin(2*pi*expPlan(nT)/period + 1); % needs round(~/dotSize)*dotSize to fix cut dots                % 			dispMod = sign(dispMod)*dispMod^2                if surfaceType == 1		   % plane                    disp = round(dispMagn*dispMod)*plane1;                elseif 	surfaceType == 2	% bar                    disp = round(dispMagn*dispMod)*plane2;                elseif surfaceType == 3	 %test epoch (square)                    if expPlan(nT) < expPlanOld % This only happens at the resets                        plane3 = base*plane1; %reinitializing plane3                        plane3((1:round(sizeSter*sizeY)),(1:round(sizeSter*sizeX))) = 1;	% quadrant                        yLoc=0; xLoc=0;                        if rand>0.5 %randomizing the location of the square                            yLoc = 1;                            plane3 = flipud(plane3);                        end                        if rand>0.5                            xLoc = 1;                            plane3 = fliplr(plane3);                        end                        sterLoc = [sterLoc 2*xLoc+yLoc+1]; %Location counter                    end %if expPlan(nT)                    disp = round(dispMagn*dispMod)*plane3;                    expPlanOld = expPlan(nT);                end %if surfaceType                            end %expPlan(nT)    end %switch motionType        %%    if fixMov        dispFix = round(dispMagn*dispMod);    else        dispFix = 0;    end        %% make dots MSB 8 nov 2010 changed to make dots twice high as wide    %% because of avotec    a = round(rand(sizeY/sizeDot,sizeX/(2*sizeDot))-.5+dens);     N = sizeDot ; % number of repetitions to scale up dot size    a = a(repmat(1:size(a,1),N,1),:)' ; % FIXME: inflate matrix msb - need to precalculate these indicies or kron?    a = a(repmat(1:size(a,1),2*N,1),:) ; % I could get rid of this if I used offscreen windows or if moglClutBlit had scaling     planeToBe{1} = a;                           a = round(rand(sizeY/sizeDot,sizeX/(2*sizeDot))-.5+dens);    N = sizeDot ; % number of repetitions    a = a(repmat(1:size(a,1),N,1),:)' ; % inflate matrix    a = a(repmat(1:size(a,1),2*N,1),:) ;     planeToBe{2} = a;        inds0 = (1:sizeXY)';    inds1 = inds0 - sizeY*disp(:);    inds1 = max(inds1,1);    inds1 = min(inds1,sizeXY);    planeToBe{2}(inds1) = planeToBe{1}(inds0);        %%     for n=1:2        % add plane        ster{n} = planeBeen{n}*2^planeToChange+planeToBe{n}*2^(1-planeToChange);        if expPlan(nT) > 0            fixType = 4;        else            fixType = ft;        end        switch fixType            case 1,                if n == 1                    ster{n}(fixInds{1}+floor(dispFix/2)*sizeY) = 4;                else                    ster{n}(fixInds{1}-ceil(dispFix/2)*sizeY) = 4;                end            case 2,                if n == 1                    ster{n}(fixInds{2}+floor(dispFix/2)*sizeY) = 4;                else                    ster{n}(fixInds{3}-ceil(dispFix/2)*sizeY) = 4;                end            case 3,                if n == 1                    ster{n}(fixInds{4}+floor(dispFix/2)*sizeY) = 4;                else                    ster{n}(fixInds{5}-ceil(dispFix/2)*sizeY) = 4;                end        end    end       WaitSecs(dT); % FIXME,  drift error. replace with:  wakeup = WaitSecs('UntilTime', when);    for n=1:2        % show dots.        tex(n) = Screen('MakeTexture',window(n),ster{n});        moglClutBlit(window(n),tex(n),clut{2-planeToChange});        Screen('Close',tex(n))%         Screen('Flip', window(n));    end     Screen('Flip', window(1), 0, 0, 1, 1); % using multiflip to sync the window flips. It seems to improve the stereo quality.endsave sterLoc sterLocmoglClutBlit();Screen('CloseAll')