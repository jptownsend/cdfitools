function CSM% This function alternates between square-wave or sine CSM and a fixed-disparity plane, with intervening gray gaps% either the fixed-disparity plane is at zero disparity% or the  fixed-disparity plane is at a disparity matching one or other of the CSM planes% msb 14 april 10 - updating for ptb3 and osx%     18 april 10 - tested and tweaked%     19 april 10 - add blanking if fixation is broken%% our avotec:  60Hz video refresh, 24 degree horiz FOV, 800x600 res%              1.8 min per pixel, 20 Hz CSM frame rate%              2x4 pixels per dot.%              ex. 2 px per dot * 1.8 min * 6 dots = 21.6 minutes amplitude%              = 43.2 minutes full scale%****************************************************%% user inputmotionType = menu('Motion type', 'Step', 'Sine');choice = menu('CSM Frequency', '0.5 Hz','1 Hz', '1.25 Hz', '2 Hz', '3.333 Hz','5 Hz');switch choice    case 1, period = 2;    case 2, period = 1;    case 3, period = 4/5;    case 4, period = 1/2;    case 5, period = 1/3;    case 6, period = 1/5;endnullType = menu('Stimulus','vs. 0 disparity ','vs. +/-disparity');close(gcf);%% settingsdispMagn = 14; %disparity amplitude in dotstestMode = 2; % normally 0, set to 1 for a vert line no rand dots, to 2 for no blanking and no MRI triggershowplan = 0; % 1show a 240plot of the exp plandT = 1/20; % interfra me periodsterShift = -48;  % to shift displays nasal or temporal, in dotssterzShift = [ 1 0 1 0 ]*sterShift;secsToDiscard = 4; % dead time up frontdummyScanDelay = 6;% delay for MRI dumm scansdTPlan = 0.005; % plan time resolutiongap=0.5; % duration of zero-disparity gap (sec)gapL=0.3; % relative luminance of the gapsizeDot = 2;  % in pixelssizeX = 800;  % in pixels, recalculated to dots below.sizeY = 300;  % FIXME: half num of pixels, we are using 2x4 dots, need sizeDotX and Ydens = 0.1; % dot density, fractionsurfaceType = 1;dispFixNull = 0; % where is the "0" disparity plane?fixType = 1;fixMov = 0;sizeFix = 6;%% timing halfPeriod = 24; % FIXME change to full periodnCycles = 3; % FIXME factor of two error in plan reps% calculated valuessizeX = round(sizeX/sizeDot) + sterShift;  % max of screen res/dotsize: moglClutBlit does not show if image too big...sizeY = round(sizeY/sizeDot);planFreq = round(1/dTPlan); % time sampling in the experimental plansizeXY = sizeX*sizeY;sterRect = [0,0,sizeDot*sizeX,sizeDot*sizeY*2]; % FIXME: half num of pixels in y, we are using 2x4 dotsnonGap = halfPeriod/2-gap; % residual non-gap durationsinePlanes = setdiff(-dispMagn:dispMagn,0); % plane depths for static control conditionnumSinePlanes = length(sinePlanes);sinePlanes = sinePlanes(randperm(numSinePlanes))/dispMagn;sinePlaneIdx = 1;sinePlaneIncr = false;%% exp plan% sampled every dTPlan=5 msnHalfPeriodPlan = round(halfPeriod*planFreq);expPlan = [+(1:nHalfPeriodPlan), -(1:nHalfPeriodPlan)]; % 1 cycleexpPlan = expPlan * halfPeriod/nHalfPeriodPlan;expPlan = kron(ones(1,nCycles+1),expPlan);expPlan = expPlan((2*nHalfPeriodPlan+1-planFreq*secsToDiscard):end); % nCycles + secsToDiscard upfrontMexpPlan=max(expPlan)/2; % precomputes max for gap insertionshift=0;gapPlan=[expPlan(end-shift+1:end) expPlan(1:end-shift)]; % shifts gapPlan FORWARD relative to expPlanep = abs(gapPlan) - MexpPlan;gep = ep - MexpPlan/2*(sign(ep)-1);%% white dots, color fixationplaneClut{1} = 255*[0,0,0;0.9,0.9,0.9];planeClut{2} = 255*[0,0,0;0.8,0.8,0.8];planeClut{3} = 255*[0,0,0;1,0.8,0.2];%% making cluts for the movieclut{1} = CombineCluts(planeClut,[1,0,2]);clut{2} = CombineCluts(planeClut,[0,1,2]);clut{1}(6:end,:)=round(255 * gapL); % grey for gap period background clut{2}(6:end,:)=round(255 * gapL);clut{1}(7:end,:)=0; % black for cross backgroundclut{2}(7:end,:)=0;%% disparity planesplane0 = zeros(sizeY,sizeX);plane1 = ones(sizeY,sizeX);plane2 = plane1; % for other shapesplane2(round(sizeY*2/5)+1:round(sizeY*3/5),:) = 0;	% stripe% plane3 = plane0;% plane3((1:round(sizeSter*sizeY)),...%     (1:round(sizeSter*sizeX))) = 1;	% quadrantplane5 = plane1*5; % grey backgroundplaneToBe = {plane0 plane0};planeBeen = planeToBe;ster = planeBeen;%% prepare fixations% cross fixationtmp = zeros(sizeY,sizeX);tmp(sizeY/2, sizeX/2-sizeFix:sizeX/2+sizeFix)=1;tmp(sizeY/2-sizeFix/2:sizeY/2+sizeFix/2, sizeX/2)=1; % FIXME: half num of pixels in y, we are using 2x4 dotsfixInds{1} = find(tmp(:));% nonius lefttmp = zeros(sizeY,sizeX);tmp(sizeY/2-2*sizeFix:sizeY/2-1,sizeX/2) = 1;fixInds{2} = find(tmp(:));% nonius righttmp = flipud(tmp);fixInds{3} = find(tmp(:));% square+nonius leftfixInds{4} = union(fixInds{1},2*sizeFix*sizeY+fixInds{2});% square+nonius rightfixInds{5} = union(fixInds{1},2*sizeFix*sizeY+fixInds{3});% square backgound for crosstmp = zeros(sizeY,sizeX);tmp(sizeY/2-sizeFix:sizeY/2+sizeFix, sizeX/2-sizeFix*2:sizeX/2+sizeFix*2)=1; % FIXME: half num of pixels in y, we are using 2x4 dotsfixInds{6} = find(tmp(:));%% open screensInitializeMatlabOpenGL([], 0, 1);screenNumber=[1,2];window = [0 0];tex = [0 0];offscreenwin = [0 0];for n = 1:2    window(n) = Screen(screenNumber(n),'OpenWindow',0);    offscreenwin(n) = Screen('OpenOffscreenWindow',window(n),0);    tex(n) = Screen('MakeTexture',window(n),ster{n});end% defining rectangleswindowRect = Screen(window(1),'Rect');sterRect = CenterRect(sterRect,windowRect);%% DAQif testMode == 0    daq = DaqDeviceIndex; % connect to USB-1208end%% diagnosticsif showplan == 1    tt=(1:length(expPlan))/planFreq;    plot(tt, expPlan,tt, abs(expPlan),tt,gep);    drawnowenddFactorSave = zeros(size(expPlan));try    %% wait to start    switch testMode        case {1,2} % test mode            fprintf('\n***Press any key to start immediately\n');            KbPressWait;        case 0 % wait for MRI trigger            countS = DaqCIn(daq);            countE = countS;            fprintf('Waiting for magnet. counter value: %d  \n',countE)            while countS == countE                countE = DaqCIn(daq);  % using counter because a DaqDIn loop was missing triggers                WaitSecs(0.1); % so we do not poll the USB-1208 too fast vbcv              end            fprintf('Rcvd trigger. counter value: %d \n',countE)            WaitSecs(dummyScanDelay);    end        k = 0;    mousebutt = [ 0 0 0 ];    t0 = GetSecs ;    when = t0 + dT; % when to wake up for next display    %% main loop    while mousebutt(1) == 0        k =  k + 1;        when = WaitSecs('UntilTime', when) + dT;        nT = ceil( (when - t0) * planFreq);        if nT > length(expPlan), break, end        planeBeen = planeToBe;        planeToChange = rem(k,2);        %% motion type        switch motionType;            case 1,                %% step CSM stereomotion: CWT                if abs(expPlan(nT)) > MexpPlan % MexpPlan magnitude selects null v. motion                    % step stereomotion null                    if surfaceType == 1                        if nullType == 1 % 0 disparity control                            dispMod = 0;                        else % nullType == 2; alternating +/- control                            dispMod = sign(expPlan(nT));                        end                    else                        dispMod = 1;                    end                else                    % step stereomotion                    dispMod = mod(expPlan(nT), period);                    if dispMod < period/2                        dispMod = 1;                    else                        dispMod = -1;                    end                end                                dFactor = round(dispMagn*dispMod);                if surfaceType == 1                    disparity = dFactor*plane1;                else                    disparity = dFactor*plane2;                end            case 2,                %% sinusoidal stereomotion                if abs(expPlan(nT)) > MexpPlan % MexpPlan magnitude selects null v. motion                    % sine stereomotion null                    if surfaceType == 1                        if nullType == 1 % 0 disparity control                            dispMod = 0;                        else % nullType == 2; random sine plane control                            if sinePlaneIncr                                sinePlaneIdx = rem(sinePlaneIdx,numSinePlanes) + 1;                                sinePlaneIncr = false;                            end                            dispMod = sinePlanes( sinePlaneIdx ); % FIXME: diff sine plane each period, no repeats.                        end                    else                        dispMod = 1;                    end                else                    % sine stereomotion                    dispMod = sin(2*pi*expPlan(nT)/period);                    sinePlaneIncr = true;                end                                dFactor = round(dispMagn*dispMod);                if surfaceType == 1                    disparity = dFactor*plane1;                else                    disparity = dFactor*plane2;                end        end        dFactorSave(nT) = dFactor;        if fixMov == 1% does fixation move?            dispFix = round(dispMagn*dispMod);        else            dispFix = dispFixNull;        end                                %% generate random dot planes with disparity        switch testMode            case 2 % no blanking                planeToBe{1} = round(rand(sizeY,sizeX)-.5+dens);                planeToBe{2} = round(rand(sizeY,sizeX)-.5+dens);            case 1 % vertical line                planeToBe{1} = zeros(sizeY,sizeX);                planeToBe{2} = zeros(sizeY,sizeX);                planeToBe{1}(:,sizeX/2) = 1;                planeToBe{2}(:,sizeX/2) = 1;            case 0 % normal                %% check fixation                dLines = DaqDIn(daq);                if dLines(1) == 255                    planeToBe{1} = round(rand(sizeY,sizeX)-.5+dens);                    planeToBe{2} = round(rand(sizeY,sizeX)-.5+dens);                else % blank display if fixation is broken                    planeToBe{1} = zeros(sizeY,sizeX);                    planeToBe{2} = zeros(sizeY,sizeX);                end        end        inds0 = (1:sizeXY)';        inds1 = inds0 - sizeY*disparity(:);        inds1 = max(inds1,1);        inds1 = min(inds1,sizeXY);        planeToBe{2}(inds1) = planeToBe{1}(inds0);                for n=1:2            % add plane            ster{n} = planeBeen{n}*2^planeToChange+planeToBe{n}*2^(1-planeToChange);            switch fixType;                case 1,                    if n == 1                        ster{n}(fixInds{6}+floor(dispFix/2)*sizeY) = 7; % background for fixation                        ster{n}(fixInds{1}+floor(dispFix/2)*sizeY) = 4;                    else                        ster{n}(fixInds{6}-ceil(dispFix/2)*sizeY) = 7;                        ster{n}(fixInds{1}-ceil(dispFix/2)*sizeY) = 4;                    end                case 2,                    if n == 1                        ster{n}(fixInds{2}+floor(dispFix/2)*sizeY) = 4;                    else                        ster{n}(fixInds{3}-ceil(dispFix/2)*sizeY) = 4;                    end                case 3,                    if n == 1                        ster{n}(fixInds{4}+floor(dispFix/2)*sizeY) = 4;                    else                        ster{n}(fixInds{5}-ceil(dispFix/2)*sizeY) = 4;                    end            end                    end                for n=1:2                        %             ep = abs(gapPlan(nT)) - MexpPlan;            %             gep = ep - MexpPlan/2*(sign(ep)-1); % generates a double-frequency ramp            if gep(nT) > nonGap; % Changes display at end of each phase "gaps"                ster{n} = plane5;                if n == 1                    ster{n}(fixInds{1}+floor(dispFix/2)*sizeY) = 4;                else                    ster{n}(fixInds{1}-ceil(dispFix/2)*sizeY) = 4;                end            end                        if k*dT<secsToDiscard % Changes display at beginning of run                ster{n} = plane5;                if n == 1                    ster{n}(fixInds{1}+floor(dispFix/2)*sizeY) = 4;                                    else                    ster{n}(fixInds{1}-ceil(dispFix/2)*sizeY) = 4;                end            end                        if n == 1                Screen(offscreenwin(n), 'PutImage', ster{n}, sterRect-sterzShift); % msb - shift in or out by sterzShift            else                                Screen(offscreenwin(n), 'PutImage', ster{n}, sterRect+sterzShift); % msb - shift in or out by sterzShift            end                        moglClutBlit(window(n),offscreenwin(n),clut{2-planeToChange});        end        % pause until next display        Screen('Flip', window(1), 0, 0, 1, 1); % using multiflip to sync the window flips. It seems to improve the stereo quality.        [~,~,mousebutt] = GetMouse;    end     %% clean up    save(['dFactorSave' num2str(now) '.mat'] , 'dFactorSave') % FIXME: record actual disp and time in seconds    moglClutBlit();    Screen('CloseAll')catch ME % do we have a problem?    moglClutBlit();    Screen('CloseAll')    disp(ME)end