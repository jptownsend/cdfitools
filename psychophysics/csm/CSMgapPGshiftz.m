 function CSMgapPGshiftz% This program alternates between square-wave or sine CSM and a fixed-disparity plane, with intervening gray gaps% either the fixed-disparity plane is at zero disparity% or the fixed-disparity plane is at a disparity matching one or other of the CSM planes% msb 14 april 10 - updating for ptb3 and osx%     18 april 10 - tested and tweaked%% our avotec:  60Hz video refresh, 24 degree horiz FOV, 800x600 res%              1.8 min per pixel, 20 Hz CSM frame rate%              4 pixels per dot.%****************************************************%% user inputmotionType = menu('Motion type', 'Step', 'Sine');choice = menu('CSM Frequency', '0.5 Hz','1 Hz', '2 Hz', '4 Hz');switch choice    case 1, period = 2;    case 2, period = 1;    case 3, period = 0.5;    case 4, period = 0.25;endnullType = menu('Stimulus','vs. 0 disparity ','vs. +/-disparity');close(gcf);%% settingstestMode = 0; % set to 1 for a vert line no rand dots.showplan = 0; % show a plot of the exp plandT = 1/20; % interframe perioddisparityMag = 3; %disparity magnitude in dotssterShift = -12;  % to shift displays nasal or temporal, in dotssterzShift = [ 1 0 1 0 ]*sterShift; % FIXME, there is a factor of two error in here...secsToDiscard = 2 ; % dead time up frontdTPlan = 0.005; % plan time resolutiongap=0.1; % duration of zero-disparity gap (sec)gapL=0.3; % relative luminance of the gapsizeDot = 4;sizeX = (800/sizeDot) + sterShift;  % max of screen res/dotsize: moglClutBlit does not show if image too big...sizeY = round(600/sizeDot);dens = 0.1; % dot densitysurfaceType = 1;dispFixNull = 0; % where is the "0" disparity planefixType = 1;fixMov = 0;sizeFix = 4;% timinghalfPeriod = 24; %Half-period of CSM2 but a full period of CSM due to four-phase cyclenCycles = 2; % 6 gives 12 cycles of CSM, six of the null depth alternation in CSM2sterRect = [0,0,sizeDot*sizeX,sizeDot*sizeY];% centerInd = (sizeX/2+0.5)*sizeY;% dispMagn=disparityMag/sizeDot;dispMagn=disparityMag;planFreq = round(1/dTPlan); % time sampling in the experimental plansizeXY = sizeX*sizeY;nonGap = halfPeriod/2-gap; % residual non-gap duration%% exp plan% sampled every dTPlan=5 msnHalfPeriodPlan = round(halfPeriod*planFreq);expPlan = [+(1:nHalfPeriodPlan), -(1:nHalfPeriodPlan)]; % 1 cycleexpPlan = expPlan * halfPeriod/nHalfPeriodPlan;expPlan = kron(ones(1,nCycles+1),expPlan); expPlan = expPlan((2*nHalfPeriodPlan+1-planFreq*secsToDiscard):end); % nCycles + secsToDiscard upfrontMexpPlan=max(expPlan)/2; %precomputes max for gap insertionshift=0;gapPlan=[expPlan(end-shift+1:end) expPlan(1:end-shift)]; %shifts gapPlan FORWARD relative to expPlanep = abs(gapPlan) - MexpPlan;gep = ep - MexpPlan/2*(sign(ep)-1);if showplan == 1    tt=(1:length(expPlan))/planFreq;    plot(tt, expPlan,tt, abs(expPlan),tt,gep);    drawnowend%% white dots, color fixationplaneClut{1} = 255*[0,0,0;1,1,1];planeClut{2} = 255*[0,0,0;1,1,1];planeClut{3} = 255*[0,0,0;1,0.8,0.2];%% making cluts for the movieclut{1} = CombineCluts(planeClut,[1,0,2]);clut{2} = CombineCluts(planeClut,[0,1,2]);clut{1}(6:end,:)=255 * gapL;clut{2}(6:end,:)=255 * gapL;clut{1}(7:end,:)=0;clut{2}(7:end,:)=0;%% disparity planesplane0 = zeros(sizeY,sizeX);plane1 = ones(sizeY,sizeX);plane2 = plane1; % for other shapesplane2(round(sizeY*2/5)+1:round(sizeY*3/5),:) = 0;	% stripe% plane3 = plane0; % plane3((1:round(sizeSter*sizeY)),...%     (1:round(sizeSter*sizeX))) = 1;	% quadrantplane5 = plane1*5; % grey backgroundplaneToBe = {plane0 plane0};planeBeen = planeToBe;ster = planeBeen;%% prepare fixations% cross fixationtmp = zeros(sizeY,sizeX);tmp(sizeY/2, sizeX/2-sizeFix:sizeX/2+sizeFix)=1; tmp(sizeY/2-sizeFix:sizeY/2+sizeFix, sizeX/2)=1;fixInds{1} = find(tmp(:));% nonius lefttmp = zeros(sizeY,sizeX);tmp(sizeY/2-2*sizeFix:sizeY/2-1,sizeX/2) = 1;fixInds{2} = find(tmp(:));% nonius righttmp = flipud(tmp);fixInds{3} = find(tmp(:));% square+nonius leftfixInds{4} = union(fixInds{1},2*sizeFix*sizeY+fixInds{2});% square+nonius rightfixInds{5} = union(fixInds{1},2*sizeFix*sizeY+fixInds{3});% square backgound for crosstmp = zeros(sizeY,sizeX);tmp(sizeY/2-sizeFix:sizeY/2+sizeFix, sizeX/2-sizeFix:sizeX/2+sizeFix)=1;fixInds{6} = find(tmp(:));%% open screensInitializeMatlabOpenGL([], 0, 1);screenNumber=[1,2];window = [0 0];tex = [0 0];offscreenwin = [0 0];for n = 1:2    window(n) = Screen(screenNumber(n),'OpenWindow',0);    offscreenwin(n) = Screen('OpenOffscreenWindow',window(n),0);    tex(n) = Screen('MakeTexture',window(n),ster{n});end% defining rectangleswindowRect = Screen(window(1),'Rect');sterRect = CenterRect(sterRect,windowRect);try    %% wait to start    fprintf('\n *** Press any key to start *** \n');    t0 = KbPressWait;    when = t0 + dT; % when to wake up for next display    %% main loop    for k=1:1000000000        when = WaitSecs('UntilTime', when) + dT;        nT = ceil( (when - t0) * planFreq);        if nT > length(expPlan), break, end        planeBeen = planeToBe;        planeToChange = rem(k,2);        %% motion type        switch motionType;            case 1, % step CSM stereomotion: CWT                if abs(expPlan(nT)) > MexpPlan % MexpPlan magnitude selects null v. motion                    % step stereomotion null                    if surfaceType == 1                        if nullType == 1 % 0 disparity control                            dispMod = 0;                        else % nullType == 2; alternating +/- control                            dispMod = sign(expPlan(nT));                        end                    else                        dispMod = 1;                    end                else                    % step stereomotion                    dispMod = mod(expPlan(nT), period);                    if dispMod < period/2                        dispMod = 1;                    else                        dispMod = -1;                    end                end                                dFactor = round(dispMagn*dispMod);                if surfaceType == 1                    disparity = dFactor*plane1;                else                    disparity = dFactor*plane2;                end                            case 2,  %sinusoidal stereomotion                if abs(expPlan(nT)) > MexpPlan                    % sine stereomotion null                    if surfaceType == 1                        if nullType == 1 % 0 disparity control                            dispMod = 0;                        else % nullType == 2; random sine +/- control, FIXME: pick from sine planes that have been shown                            dispMod = sign(expPlan(nT))/2;                        end                    else                        dispMod = 1;                    end                else                    % sine stereomotion                    dispMod = sin(2*pi*expPlan(nT)/period);                end                                dFactor = round(dispMagn*dispMod);                if surfaceType == 1                    disparity = dFactor*plane1;                else                    disparity = dFactor*plane2;                end        end                if fixMov % does fixation move?            dispFix = round(dispMagn*dispMod);        else            dispFix = dispFixNull;        end                %% generate random dot planes with disparity        switch testMode                        case 2                planeToBe{1} = ones(sizeY,sizeX);                planeToBe{2} = ones(sizeY,sizeX);            case 1                planeToBe{1} = round(zeros(sizeY,sizeX)-.5+dens);                planeToBe{2} = round(zeros(sizeY,sizeX)-.5+dens);                planeToBe{1}(:,sizeX/2) = 1;                planeToBe{2}(:,sizeX/2) = 1;            case 0                planeToBe{1} = round(rand(sizeY,sizeX)-.5+dens);                planeToBe{2} = round(rand(sizeY,sizeX)-.5+dens);        end        inds0 = (1:sizeXY)';        inds1 = inds0 - sizeY*disparity(:);        inds1 = max(inds1,1);        inds1 = min(inds1,sizeXY);        planeToBe{2}(inds1) = planeToBe{1}(inds0);                for n=1:2            % add plane            ster{n} = planeBeen{n}*2^planeToChange+planeToBe{n}*2^(1-planeToChange);            switch fixType;                case 1,                    if n == 1                        ster{n}(fixInds{6}+floor(dispFix/2)*sizeY) = 7;                        ster{n}(fixInds{1}+floor(dispFix/2)*sizeY) = 4;                    else                        ster{n}(fixInds{6}-ceil(dispFix/2)*sizeY) = 7;                        ster{n}(fixInds{1}-ceil(dispFix/2)*sizeY) = 4;                    end                case 2,                    if n == 1                        ster{n}(fixInds{2}+floor(dispFix/2)*sizeY) = 4;                    else                        ster{n}(fixInds{3}-ceil(dispFix/2)*sizeY) = 4;                    end                case 3,                    if n == 1                        ster{n}(fixInds{4}+floor(dispFix/2)*sizeY) = 4;                    else                        ster{n}(fixInds{5}-ceil(dispFix/2)*sizeY) = 4;                    end            end                    end                for n=1:2            %             ep = abs(gapPlan(nT)) - MexpPlan;%             gep = ep - MexpPlan/2*(sign(ep)-1); % generates a double-frequency ramp            if gep(nT) > nonGap; % Changes display at end of each phase "gaps"                ster{n} = plane5;                if n == 1                    ster{n}(fixInds{1}+floor(dispFix/2)*sizeY) = 4;                else                    ster{n}(fixInds{1}-ceil(dispFix/2)*sizeY) = 4;                end            end                        if k*dT<secsToDiscard % Changes display at beginning of run                ster{n} = plane5;                if n == 1                    ster{n}(fixInds{1}+floor(dispFix/2)*sizeY) = 4;                else                    ster{n}(fixInds{1}-ceil(dispFix/2)*sizeY) = 4;                end            end                        Screen(offscreenwin(n), 'PutImage', ster{n}, sterRect+sterzShift*((n-1.5)*2)); % msb - shift in or out by sterzShift            moglClutBlit(window(n),offscreenwin(n),clut{2-planeToChange});        end        % pause until next display        Screen('Flip', window(1), 0, 0, 1, 1); % using multiflip to sync the window flips. It seems to improve the stereo quality.     end        %% clean up    moglClutBlit();    Screen('CloseAll')catch ME % do we have a problem?    moglClutBlit();    Screen('CloseAll')    disp(ME)end